<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>面对对象版拖拽</title>
    <style type="text/css">
        *{
            margin:0;
            padding:0;
        }
        #box1{
            width:100px;
            height:100px;
            position: absolute;
            top: 0;
            left: 0;
            background: red;
            border-radius: 50%;
            cursor:move;
        }

        #box2 {
            width: 100px;
            height: 100px;
            position: absolute;
            top: 120px;;
            left: 0;
            background: lightblue;
            border-radius: 50%;
            cursor:move;
        }

        #box3 {
            width: 100px;
            height: 100px;
            position: absolute;
            top: 0;
            left: 120px;;
            background: lightcoral;
            border-radius: 50%;
            cursor:move;
        }

    </style>
</head>
<body>
<div id="box1"></div>
<div id="box2"></div>
<div id="box3"></div>

<script type="text/javascript" src="../js/eventcheng.js"></script>
\
<script type="text/javascript">

    //面向对象来写拖拽的功能，相对于执行的设计模式的区别就是，把拖拽和自定义方法库，全部都是封装成一个类，通过原型继承的方式，让拖拽类能够用这个自定义事件库类的方法，用这些方法类为拖拽的各个阶段增加接口，那么使用的时候，直接就可以通过实例调用的方式，调用on方法向对应的阶段添加方法；
    //关于this问题，主要在写各个类的时候，要让类上的方法执行的时候都是当前类的实例，而且通过on绑定上来的方法，也要通过fire中的a[i].call(this,e).把其中的this转化为当前类的实例；
    //使用面对对象的方式来写拖拽，主要就是为了可以随时可以在原有版本的基础上来增加新的功能，还可以直接不改动其中之前代码的情况之下，升级版本，主要都是通过fire（type，e）；这个借口来操作；

    function EventEmitter(){    };

    EventEmitter.prototype.on = function (type,fn){
        if(!this["aEvent"+type]){
            this["aEvent"+type]=[];
        }
        var a=this["aEvent"+type];
        for(var i=0;i< a.length;i++){
            if(a[i]===fn){
                return this
            }
        }
        a.push(fn);
        return this
    };

    EventEmitter.prototype.fire=function(type,e){

        var a=this["aEvent"+ type];
        if(a){//这个一定要写，，因为当第一次循环的时候点击元素对应方法的时候，有可能这个借口的事件库中还没有绑定方法
            for(var i=0;i< a.length;i++){
                if(typeof a[i]==="function"){
                    a[i].call(this,e);//给这个拖拽类扩展方法，只需要让这些方法中的this确定是当前元素即可，怎么实现呢，通过fire执行的时候，让其中的方法中的this变为这个；
                }else{
                    a.slice(i,1);
                    i--;
                }
            }
        }
    };

    EventEmitter.prototype.off=function(type,fn){
        var a=this["aEvent"+type];
        if(a){
            for(var i=0;i< a.length;i++){
                if(a[i]===fn){
                    a[i]=null;
                    return this
                }
            }
        }
    };



    function Drag(ele) {
        this.x = null;
        this.y = null;
        this.mx = null;
        this.my = null;
        this.ele= ele;

        this.DOWN=processThis(this.down,this);
        this.MOVE=processThis(this.move,this);
        this.UP= processThis(this.up,this);

        on(this.ele,"mousedown",this.DOWN);//设计原则，让所有原型上的方法 this都是当前实例；
    }

    Drag.prototype=new EventEmitter;

    Drag.prototype.down=function(e){
        this.x=this.ele.offsetLeft;
        this.y=this.ele.offsetTop;
        this.mx= e.pageX;
        this.my= e.pageY;

        if(this.ele.setCapture){
            this.ele.setCapture();
            on(this.ele,"mousemove",this.MOVE);
            on(this.ele,"mouseup",this.UP)
            return
        }
        on(document,"mousemove",this.MOVE);
        on(document,"mouseup",this.UP);

        e.preventDefault();

        this.fire("selfDragStart",e);
    };

    Drag.prototype.move=function(e){
        this.ele.style.left= e.pageX-this.mx+this.x+"px";
        this.ele.style.top= e.pageY-this.my+this.y+"px";

        this.fire("selfDrag",e);

    };


    Drag.prototype.up=function(e){
        if(this.ele.releaseCapture){
            this.ele.releaseCapture();
            off(this.ele,"mousemove",this.MOVE);
            off(this.ele,"mouseup",this.UP);

        }
        off(document,"mousemove",this.MOVE);
        off(document,"mouseup",this.UP);

        this.fire("selfDragEnd",e);

    };

    Drag.prototype.border=function(){
        this.on("selfDragStart",this.addBorder);
        this.on("selfDragEnd",this.removeBorder);
    };

    Drag.prototype.addBorder=function(){
        this.ele.style.border="1px solid black";
    };

    Drag.prototype.removeBorder=function(){
        this.ele.style.border="1px dash blue";
    };




    var oBox=document.getElementsByTagName("div");
    for(var i=0;i<oBox.length;i++){
        var curDiv=oBox[i];
        var obj=new Drag(curDiv);//这里的curDIV不用加双引号；
        new Drag(curDiv).on("selfDragStart",clearEffect).on("selfDrag",getSpeed).on("selfDragEnd",fly).on("selfDragEnd",drop);
        obj.border();
    }


    function clearEffect(){
        clearTimeout(this.ele.flyTimer);
        clearTimeout(this.ele.dropTimer);
    }

    function getSpeed(e){
        if(this.ele.posi){
            this.ele.speed=this.ele.offsetLeft-this.ele.posi;
            this.ele.posi=this.ele.offsetLeft;
        }else{
            this.ele.posi=this.ele.offsetLeft;
        }
    }

    function fly(){
        this.ele.speed*=.97;
        var val=this.ele.offsetLeft+this.ele.speed;
        var maxRight=(document.documentElement.clientWidth||document.body.clientWidth)-this.ele.offsetWidth;
        if(val>maxRight){
            this.ele.style.left=val;
            this.ele.speed*=-1;
        }else if(val<0){
            this.ele.style.left=0;
            this.ele.speed*=-1;
        }
        this.ele.style.left=this.ele.offsetLeft+this.ele.speed+"px";

        if(Math.abs(this.ele.speed)>0.5){
            this.flyTimer=setTimeout(processThis(fly,this),30);
        }
    }

    function drop(){
        if(this.ele.dropspeed){
            this.ele.dropspeed+=9.8;
        }else{
            this.ele.dropspeed=9.8;
        }
        this.ele.dropspeed*=0.97;
        var val2=this.ele.offsetTop+this.ele.dropspeed;
        var maxBottom=(document.documentElement.clientHeight||document.body.clientHeight)-this.ele.offsetHeight;
        if(val2>maxBottom){
            this.ele.style.top=maxBottom+"px";
            this.ele.dropspeed*=-1;
            this.ele.flag++
        }else{
            this.ele.style.top=this.ele.offsetTop+this.ele.dropspeed+"px";
            this.ele.flag=0;
        }

        if(this.ele.flag<2){
            this.ele.dropTimer=setTimeout(processThis(drop,this),30);
        }
    }

</script>
</body>
</html>